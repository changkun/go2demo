// Code generated by go2go; DO NOT EDIT.


//line sched_test.go2:1
package sched

//line sched_test.go2:1
import (
//line sched_test.go2:1
 "container/heap"
//line sched_test.go2:1
 "context"
//line sched_test.go2:1
 "fmt"
//line sched_test.go2:1
 "reflect"
//line sched_test.go2:1
 "runtime"
//line sched_test.go2:1
 "sync"
//line sched_test.go2:1
 "sync/atomic"
//line sched_test.go2:1
 "testing"
//line sched_test.go2:1
 "time"
//line sched_test.go2:1
 "unsafe"
//line sched_test.go2:1
)

//line sched_test.go2:393
type CustomTask struct {
	Public    string
	id        string
	execution time.Time
}

//line sched_test.go2:400
func NewCustomTask(id string, e time.Time) *CustomTask {
	return &CustomTask{
		Public:    "not nil",
		id:        id,
		execution: e,
	}
}

//line sched_test.go2:409
func (t *CustomTask) GetID() (id string) {
	id = t.id
	return
}

//line sched_test.go2:415
func (t *CustomTask) GetExecution() (execute time.Time) {
	execute = t.execution
	return
}

//line sched_test.go2:421
func (t *CustomTask) GetTimeout() (executeTimeout time.Duration) {
	return time.Second
}

//line sched_test.go2:426
func (t *CustomTask) GetRetryTime() time.Time {
	return time.Now().UTC().Add(time.Second)
}

//line sched_test.go2:431
func (t *CustomTask) SetID(id string) {
	t.id = id
}

//line sched_test.go2:436
func (t *CustomTask) IsValidID() bool {
	return true
}

//line sched_test.go2:441
func (t *CustomTask) SetExecution(current time.Time) (old time.Time) {
	old = t.execution
	t.execution = current
	return
}

//line sched_test.go2:448
func (t *CustomTask) Execute() (r string, retry bool, fail error) {
	O.Push(t.id)
	return fmt.Sprintf("execute task %s.", t.id), false, nil
}

//line sched_test.go2:454
func TestSchedMasiveSchedule(t *testing.T) {
	O.Clear()
	nTasks := 100
	sched0 := instantiate୦୦NewSched୦string୦୮1sched୮aCustomTask()
	futures := make([]*instantiate୦୦Future୦string, nTasks)

	defer sched0.Stop()
	defer sched0.Wait()

	start := time.Now().UTC()
	expectedOrder := []string{}

	for i := 0; i < nTasks; i++ {
		key := fmt.Sprintf("task-%d", i)
		task := NewCustomTask(key, start.Add(time.Millisecond*10*time.Duration(i)))
		expectedOrder = append(expectedOrder, key)
		future := sched0.Submit(task)
		futures[i] = future
	}
	for i := range futures {
		fmt.Println(futures[i].Get())
	}
	if !reflect.DeepEqual(expectedOrder, O.Get()) {
		t.Errorf("execution order wrong, got: %v", O.Get())
	}
}

//line sched_test.go2:482
var O = Order{}

//line sched_test.go2:485
type Order struct {
	mu    sync.Mutex
	order []string
	first time.Time
	last  time.Time
}

//line sched_test.go2:493
func (o *Order) Push(s string) {
	o.mu.Lock()
	o.order = append(o.order, s)
	o.mu.Unlock()
}

//line sched_test.go2:500
func (o *Order) IsFirstZero() bool {
	o.mu.Lock()
	defer o.mu.Unlock()
	return o.first.IsZero()
}

//line sched_test.go2:507
func (o *Order) SetFirst(t time.Time) {
	o.mu.Lock()
	o.first = t
	o.mu.Unlock()
}

//line sched_test.go2:514
func (o *Order) GetFirst() time.Time {
	o.mu.Lock()
	defer o.mu.Unlock()
	return o.first
}

//line sched_test.go2:521
func (o *Order) SetLast(t time.Time) {
	o.mu.Lock()
	o.last = t
	o.mu.Unlock()
}

//line sched_test.go2:528
func (o *Order) GetLast() time.Time {
	o.mu.Lock()
	defer o.mu.Unlock()
	return o.last
}

//line sched_test.go2:535
func (o *Order) Get() []string {
	o.mu.Lock()
	defer o.mu.Unlock()
	return o.order
}

//line sched_test.go2:542
func (o *Order) Clear() {
	o.mu.Lock()
	o.order = []string{}
	o.first = time.Time{}
	o.last = time.Time{}
	o.mu.Unlock()
}
//line sched_test.go2:72
func instantiate୦୦NewSched୦string୦୮1sched୮aCustomTask() *instantiate୦୦sched୦string୦୮1sched୮aCustomTask {
	return &instantiate୦୦sched୦string୦୮1sched୮aCustomTask{
		timer: unsafe.Pointer(time.NewTimer(0)),
		tasks: instantiate୦୦newTaskQueue୦string(),
	}
}

//line sched_test.go2:77
type instantiate୦୦Future୦string struct {
//line sched_test.go2:18
 Err   error
				value atomic.Value
}

//line sched_test.go2:23
func (f *instantiate୦୦Future୦string,) Get() string {
	var v interface{}

	for ; v == nil && f.Err == nil; v = f.value.Load() {
		runtime.Gosched()
	}
	return v.(string)
}

func (f *instantiate୦୦Future୦string,) put(v string) {
	f.value.Store(v)
}

//line sched_test.go2:34
type instantiate୦୦sched୦string୦୮1sched୮aCustomTask struct {
//line sched_test.go2:60
 running uint64

	pausing uint64

	timer unsafe.Pointer

	cancel atomic.Value

	tasks *instantiate୦୦taskQueue୦string
}

//line sched_test.go2:81
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Stop() {
				sched0.Pause()

//line sched_test.go2:85
 for atomic.LoadUint64(&sched0.running) > 0 {
		runtime.Gosched()
	}

//line sched_test.go2:90
 atomic.AddUint64(&sched0.pausing, ^uint64(0))
}

//line sched_test.go2:94
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Wait() {

	for sched0.tasks.length() != 0 {
		runtime.Gosched()
	}
}

//line sched_test.go2:102
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Submit(t *CustomTask) *instantiate୦୦Future୦string {
	return sched0.schedule(t, t.GetExecution())
}

//line sched_test.go2:107
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Trigger(t *CustomTask) *instantiate୦୦Future୦string {
	return sched0.schedule(t, time.Now())
}

//line sched_test.go2:112
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Pause() {
	atomic.AddUint64(&sched0.pausing, 1)
	sched0.pause()
}

//line sched_test.go2:119
func (sched0 *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) Resume() {
	atomic.AddUint64(&sched0.pausing, ^uint64(0))
	sched0.resume()
}

//line sched_test.go2:125
func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) schedule(t *CustomTask, when time.Time) *instantiate୦୦Future୦string {
				s.pause()

//line sched_test.go2:129
 if future, ok := s.tasks.update(t, when); ok {
		s.resume()
		return future
	}

	future := s.tasks.push(instantiate୦୦newTaskItem୦string(t, when))
	s.resume()
	return future
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) reschedule(t *instantiate୦୦task୦string, when time.Time) {
	s.pause()
	t.priority = when
	s.tasks.push(t)
	s.resume()
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) getTimer() (t *time.Timer) {
	for {
		t = (*time.Timer)(atomic.LoadPointer(&s.timer))
		if t != nil {
			return
		}
		runtime.Gosched()
	}
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) setTimer(d time.Duration) {
	for {

		old := atomic.SwapPointer(&s.timer, nil)
		if old != nil {
			if (*time.Timer)(old).Stop() {
				(*time.Timer)(old).Reset(d)
				if atomic.CompareAndSwapPointer(&s.timer, nil, old) {
					return
				}
				runtime.Gosched()
				continue
			}
		}

//line sched_test.go2:173
  if atomic.CompareAndSwapPointer(&s.timer, old,
			unsafe.Pointer(time.NewTimer(d))) {
			if old != nil {
				(*time.Timer)(old).Stop()
			}
			return
		}
		runtime.Gosched()
	}
}

//line sched_test.go2:185
func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) pause() {
	old := atomic.LoadPointer(&s.timer)

	if old != nil {
		(*time.Timer)(old).Stop()
	}
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) resume() {

	ctx, cancel := context.WithCancel(context.Background())
	if x, ok := s.cancel.Load().(context.CancelFunc); ok {
		x()
	}
	s.cancel.Store(cancel)

	t := s.tasks.peek()
	if t == nil {
		return
	}
	s.setTimer(t.GetExecution().Sub(time.Now()))

	go func(ctx context.Context) {
		select {
		case <-s.getTimer().C:
			s.worker()
		case <-ctx.Done():
		}
	}(ctx)
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) worker() {

//line sched_test.go2:219
 if atomic.LoadUint64(&s.pausing) > 0 {
		return
	}

//line sched_test.go2:225
 task := s.tasks.pop()
	if task == nil {
		return
	}

	s.resume()
	s.arrival(task)
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) arrival(t *instantiate୦୦task୦string,) {

	atomic.AddUint64(&s.running, 1)
	s.execute(t)
	atomic.AddUint64(&s.running, ^uint64(0))
}

func (s *instantiate୦୦sched୦string୦୮1sched୮aCustomTask,) execute(t *instantiate୦୦task୦string,) {
	defer func() {
		if r := recover(); r != nil {
			t.future.Err = fmt.Errorf(
				"sched: task %s panic while executing, reason: %v",
				t.value.GetID(), r)
		}
	}()

//line sched_test.go2:251
 if t.value.GetExecution().After(time.Now()) {

		s.reschedule(t, t.value.GetExecution())
		return
	}
	result, retry, err := t.value.Execute()
	if retry || err != nil {
		s.reschedule(t, t.value.GetRetryTime())
		return
	}
	t.future.put(result)
}

//line sched_test.go2:275
func instantiate୦୦newTaskQueue୦string() *instantiate୦୦taskQueue୦string {
	return &instantiate୦୦taskQueue୦string{
		heap:   &instantiate୦୦taskHeap୦string{},
		lookup: map[string]*instantiate୦୦task୦string{},
	}
}

//line sched_test.go2:280
type instantiate୦୦taskQueue୦string struct {
//line sched_test.go2:270
 heap   *instantiate୦୦taskHeap୦string
				lookup map[string]*instantiate୦୦task୦string
				mu     sync.Mutex
}

//line sched_test.go2:283
func (m *instantiate୦୦taskQueue୦string,) length() (l int) {
	m.mu.Lock()
	l = m.heap.Len()
	m.mu.Unlock()
	return
}

//line sched_test.go2:291
func (m *instantiate୦୦taskQueue୦string,) push(t *instantiate୦୦task୦string,) *instantiate୦୦Future୦string {
	m.mu.Lock()
	heap.Push(m.heap, t)
	m.lookup[t.value.GetID()] = t
	m.mu.Unlock()
	return t.future
}

//line sched_test.go2:300
func (m *instantiate୦୦taskQueue୦string,) pop() *instantiate୦୦task୦string {
	m.mu.Lock()

	if m.heap.Len() == 0 {
		m.mu.Unlock()
		return nil
	}

	item := heap.Pop(m.heap).(*instantiate୦୦task୦string)
	delete(m.lookup, item.value.GetID())
	m.mu.Unlock()
	return item
}

//line sched_test.go2:315
func (m *instantiate୦୦taskQueue୦string,) peek() (t instantiate୦୦Task୦string,) {
	m.mu.Lock()

	if m.heap.Len() == 0 {
		m.mu.Unlock()
		return nil
	}
	t = (*m.heap)[0].value
	m.mu.Unlock()
	return
}

//line sched_test.go2:328
func (m *instantiate୦୦taskQueue୦string,) update(t instantiate୦୦Task୦string, when time.Time) (*instantiate୦୦Future୦string, bool) {
	m.mu.Lock()
	item, ok := m.lookup[t.GetID()]
	if !ok {
		m.mu.Unlock()
		return nil, false
	}

	item.priority = when
	item.value = t
	heap.Fix(m.heap, item.index)
	m.mu.Unlock()
	return item.future, true
}

//line sched_test.go2:355
func instantiate୦୦newTaskItem୦string(t instantiate୦୦Task୦string, when time.Time) *instantiate୦୦task୦string {
	return &instantiate୦୦task୦string{value: t, priority: when, future: &instantiate୦୦Future୦string{}}
}

//line sched_test.go2:357
type instantiate୦୦task୦string struct {
//line sched_test.go2:345
 value instantiate୦୦Task୦string

//line sched_test.go2:349
 index int
	priority time.Time
	future   *instantiate୦୦Future୦string
}
//line sched_test.go2:352
type instantiate୦୦taskHeap୦string []*instantiate୦୦task୦string

//line sched_test.go2:361
func (pq instantiate୦୦taskHeap୦string,) Len() int {
	return len(pq)
}

func (pq instantiate୦୦taskHeap୦string,) Less(i, j int) bool {
	return pq[i].priority.Before(pq[j].priority)
}

func (pq instantiate୦୦taskHeap୦string,) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = i
	pq[j].index = j
}

func (pq *instantiate୦୦taskHeap୦string,) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	*pq = old[0 : n-1]
	return item
}

func (pq *instantiate୦୦taskHeap୦string,) Push(x interface{}) {
	item := x.(*instantiate୦୦task୦string)
	item.index = len(*pq)
	*pq = append(*pq, item)
}

//line sched_test.go2:387
type instantiate୦୦Task୦string interface {
//line sched_test.go2:40
 GetID() (id string)

				GetExecution() (execute time.Time)

				GetRetryTime() (execute time.Time)

//line sched_test.go2:47
 Execute() (result string, retry bool, fail error)
}

//line sched_test.go2:48
var _ = heap.Fix
//line sched_test.go2:48
var _ = context.Background
//line sched_test.go2:48
var _ = fmt.Errorf
//line sched_test.go2:48
var _ = reflect.Append
//line sched_test.go2:48
var _ = runtime.BlockProfile

//line sched_test.go2:48
type _ sync.Cond

//line sched_test.go2:48
var _ = atomic.AddInt32
//line sched_test.go2:48
var _ = testing.AllocsPerRun

//line sched_test.go2:48
const _ = time.ANSIC

//line sched_test.go2:48
type _ unsafe.Pointer
