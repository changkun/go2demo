// Code generated by go2go; DO NOT EDIT.


//line set_test.go2:1
package sets

import (
	"sort"
	"testing"

	"github.com/changkun/go2generics/slices"
)

func TestSet(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	if got := s1.Len(); got != 0 {
		t.Errorf("Len of empty set = %d, want 0", got)
	}
	s1.Add(1)
	s1.Add(1)
	s1.Add(1)
	if got := s1.Len(); got != 1 {
		t.Errorf("(%v).Len() == %d, want 1", s1, got)
	}
	s1.Add(2)
	s1.Add(3)
	s1.Add(4)
	if got := s1.Len(); got != 4 {
		t.Errorf("(%v).Len() == %d, want 4", s1, got)
	}
	if !s1.Contains(1) {
		t.Errorf("(%v).Contains(1) == false, want true", s1)
	}
	if s1.Contains(5) {
		t.Errorf("(%v).Contains(5) == true, want false", s1)
	}
	vals := s1.Values()
	sort.Ints(vals)
	w1 := []int{1, 2, 3, 4}
	if !instantiate୦slices୦Equal୦int(vals, w1) {
		t.Errorf("(%v).Values() == %v, want %v", s1, vals, w1)
	}
}

func TestEqual(t *testing.T) {
	s1 := instantiate୦୦Make୦string()
	s2 := instantiate୦୦Make୦string()
	if !instantiate୦୦Equal୦string(s1, s2) {
		t.Errorf("Equal(%v, %v) = false, want true", s1, s2)
	}
	s1.Add("hello")
	s1.Add("world")
	if got := s1.Len(); got != 2 {
		t.Errorf("(%v).Len() == %d, want 2", s1, got)
	}
	if instantiate୦୦Equal୦string(s1, s2) {
		t.Errorf("Equal(%v, %v) = true, want false", s1, s2)
	}
}

func TestCopy(t *testing.T) {
	s1 := instantiate୦୦Make୦float64()
	s1.Add(0)
	s2 := s1.Copy()
	if !instantiate୦୦Equal୦float64(s1, s2) {
		t.Errorf("Equal(%v, %v) = false, want true", s1, s2)
	}
	s1.Add(1)
	if instantiate୦୦Equal୦float64(s1, s2) {
		t.Errorf("Equal(%v, %v) = true, want false", s1, s2)
	}
}

func TestAddSet(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	s1.Add(1)
	s1.Add(2)
	s2 := instantiate୦୦Make୦int()
	s2.Add(2)
	s2.Add(3)
	s1.AddSet(s2)
	if got := s1.Len(); got != 3 {
		t.Errorf("(%v).Len() == %d, want 3", s1, got)
	}
	s2.Add(1)
	if !instantiate୦୦Equal୦int(s1, s2) {
		t.Errorf("Equal(%v, %v) = false, want true", s1, s2)
	}
}

func TestSubSet(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	s1.Add(1)
	s1.Add(2)
	s2 := instantiate୦୦Make୦int()
	s2.Add(2)
	s2.Add(3)
	s1.SubSet(s2)
	if got := s1.Len(); got != 1 {
		t.Errorf("(%v).Len() == %d, want 1", s1, got)
	}
	if vals, want := s1.Values(), []int{1}; !instantiate୦slices୦Equal୦int(vals, want) {
		t.Errorf("after SubSet got %v, want %v", vals, want)
	}
}

func TestIntersect(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	s1.Add(1)
	s1.Add(2)
	s2 := instantiate୦୦Make୦int()
	s2.Add(2)
	s2.Add(3)
	s1.Intersect(s2)
	if got := s1.Len(); got != 1 {
		t.Errorf("(%v).Len() == %d, want 1", s1, got)
	}
	if vals, want := s1.Values(), []int{2}; !instantiate୦slices୦Equal୦int(vals, want) {
		t.Errorf("after Intersect got %v, want %v", vals, want)
	}
}

func TestIterate(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	s1.Add(1)
	s1.Add(2)
	s1.Add(3)
	s1.Add(4)
	tot := 0
	s1.Iterate(func(i int) { tot += i })
	if tot != 10 {
		t.Errorf("total of %v == %d, want 10", s1, tot)
	}
}

func TestFilter(t *testing.T) {
	s1 := instantiate୦୦Make୦int()
	s1.Add(1)
	s1.Add(2)
	s1.Add(3)
	s1.Filter(func(v int) bool { return v%2 == 0 })
	if vals, want := s1.Values(), []int{2}; !instantiate୦slices୦Equal୦int(vals, want) {
		t.Errorf("after Filter got %v, want %v", vals, want)
	}

}
//line set.go2:7
func instantiate୦୦Make୦int() instantiate୦୦Set୦int {
	return make(instantiate୦୦Set୦int)
}

//line set_test.go2:11
func instantiate୦slices୦Equal୦int(s1, s2 []int,) bool {
//line set_test.go2:13
 if len(s1) != len(s2) {
		return false
//line set_test.go2:16
 }
//line set_test.go2:16
 for i, v1 := range s1 {
//line set_test.go2:18
  v2 := s2[i]
//line set_test.go2:18
  if v1 !=
			v2 {
//line set_test.go2:19
   if !instantiate୦math୦IsNaN୦int(v1) || !instantiate୦math୦IsNaN୦int(v2) {

				return false
			}
//line set_test.go2:22
  }
	}
//line set_test.go2:23
 return true
}
//line set.go2:7
func instantiate୦୦Make୦string() instantiate୦୦Set୦string {
	return make(instantiate୦୦Set୦string)
}

//line set.go2:40
func instantiate୦୦Equal୦string(s1, s2 instantiate୦୦Set୦string,) bool {
	if len(s1) != len(s2) {
		return false
	}
	for v1 := range s1 {
		if !s2.Contains(v1) {
			return false
		}
	}
	return true
}
//line set.go2:7
func instantiate୦୦Make୦float64() instantiate୦୦Set୦float64 {
	return make(instantiate୦୦Set୦float64)
}

//line set.go2:40
func instantiate୦୦Equal୦float64(s1, s2 instantiate୦୦Set୦float64,) bool {
	if len(s1) != len(s2) {
		return false
	}
	for v1 := range s1 {
		if !s2.Contains(v1) {
			return false
		}
	}
	return true
}
//line set.go2:40
func instantiate୦୦Equal୦int(s1, s2 instantiate୦୦Set୦int,) bool {
	if len(s1) != len(s2) {
		return false
	}
	for v1 := range s1 {
		if !s2.Contains(v1) {
			return false
		}
	}
	return true
}

//line set.go2:50
type instantiate୦୦Set୦int map[int]struct{}

//line set.go2:11
func (s instantiate୦୦Set୦int,) Add(v int) {
	s[v] = struct{}{}
}

func (s instantiate୦୦Set୦int,) Delete(v int,

//line set.go2:15
) {
	delete(s, v)
}

func (s instantiate୦୦Set୦int,) Contains(v int,

//line set.go2:19
) bool {
	_, ok := s[v]
	return ok
}

func (s instantiate୦୦Set୦int,) Len() int {
	return len(s)
}

func (s instantiate୦୦Set୦int,) Iterate(f func(int,

//line set.go2:28
)) {
	for v := range s {
//line set.go2:29
  f(v)
//line set.go2:29
 }
}

func (s instantiate୦୦Set୦int,) Values() []int {
	r := make([]int, 0, len(s))
	for v := range s {
		r = append(r, v)
	}
	return r
}

//line set.go2:52
func (s instantiate୦୦Set୦int,) Copy() instantiate୦୦Set୦int {
	r := instantiate୦୦Set୦int(make(map[int]struct{}, len(s)))
	for v := range s {
		r[v] = struct{}{}
	}
	return r
}

func (s instantiate୦୦Set୦int,) AddSet(s2 instantiate୦୦Set୦int,) {
	for v := range s2 {
		s[v] = struct{}{}
	}
}

func (s instantiate୦୦Set୦int,) SubSet(s2 instantiate୦୦Set୦int,) {
	for v := range s2 {
		delete(s, v)
	}
}

func (s instantiate୦୦Set୦int,) Intersect(s2 instantiate୦୦Set୦int,) {
	for v := range s {
		if !s2.Contains(v) {
			delete(s, v)
		}
	}
}

func (s instantiate୦୦Set୦int,) Filter(f func(int,

//line set.go2:80
) bool) {
	for v := range s {
		if !f(v) {
			delete(s, v)
		}
	}
}
//line set.go2:67
func instantiate୦math୦IsNaN୦int(e int,) bool {
//line set.go2:72
 return e != e
//line set.go2:72
}

//line set.go2:72
type instantiate୦୦Set୦string map[string]struct{}

//line set.go2:11
func (s instantiate୦୦Set୦string,) Add(v string) {
	s[v] = struct{}{}
}

func (s instantiate୦୦Set୦string,) Delete(v string) {
	delete(s, v)
}

func (s instantiate୦୦Set୦string,) Contains(v string) bool {
	_, ok := s[v]
	return ok
}

func (s instantiate୦୦Set୦string,) Len() int {
	return len(s)
}

func (s instantiate୦୦Set୦string,) Iterate(f func(

//line set_test.go2:42
 string)) {
//line set.go2:29
 for v := range s {
//line set.go2:29
  f(v)
//line set.go2:29
 }
}

func (s instantiate୦୦Set୦string,) Values() []string {
	r := make([]string, 0, len(s))
	for v := range s {
		r = append(r, v)
	}
	return r
}

//line set.go2:52
func (s instantiate୦୦Set୦string,) Copy() instantiate୦୦Set୦string {
	r := instantiate୦୦Set୦string(make(map[string]struct{}, len(s)))
	for v := range s {
		r[v] = struct{}{}
	}
	return r
}

func (s instantiate୦୦Set୦string,) AddSet(s2 instantiate୦୦Set୦string,) {
	for v := range s2 {
		s[v] = struct{}{}
	}
}

func (s instantiate୦୦Set୦string,) SubSet(s2 instantiate୦୦Set୦string,) {
	for v := range s2 {
		delete(s, v)
	}
}

func (s instantiate୦୦Set୦string,) Intersect(s2 instantiate୦୦Set୦string,) {
	for v := range s {
		if !s2.Contains(v) {
			delete(s, v)
		}
	}
}

func (s instantiate୦୦Set୦string,) Filter(f func(string,

//line set.go2:80
) bool) {
	for v := range s {
		if !f(v) {
			delete(s, v)
		}
	}
}

//line set.go2:86
type instantiate୦୦Set୦float64 map[float64]struct{}

//line set.go2:11
func (s instantiate୦୦Set୦float64,) Add(v float64) {
	s[v] = struct{}{}
}

func (s instantiate୦୦Set୦float64,) Delete(v float64) {
	delete(s, v)
}

func (s instantiate୦୦Set୦float64,) Contains(v float64) bool {
	_, ok := s[v]
	return ok
}

func (s instantiate୦୦Set୦float64,) Len() int {
	return len(s)
}

func (s instantiate୦୦Set୦float64,) Iterate(f func(

//line set_test.go2:58
 float64)) {
//line set.go2:29
 for v := range s {
//line set.go2:29
  f(v)
//line set.go2:29
 }
}

func (s instantiate୦୦Set୦float64,) Values() []float64 {
	r := make([]float64, 0, len(s))
	for v := range s {
		r = append(r, v)
	}
	return r
}

//line set.go2:52
func (s instantiate୦୦Set୦float64,) Copy() instantiate୦୦Set୦float64 {
	r := instantiate୦୦Set୦float64(make(map[float64]struct{}, len(s)))
	for v := range s {
		r[v] = struct{}{}
	}
	return r
}

func (s instantiate୦୦Set୦float64,) AddSet(s2 instantiate୦୦Set୦float64,) {
	for v := range s2 {
		s[v] = struct{}{}
	}
}

func (s instantiate୦୦Set୦float64,) SubSet(s2 instantiate୦୦Set୦float64,) {
	for v := range s2 {
		delete(s, v)
	}
}

func (s instantiate୦୦Set୦float64,) Intersect(s2 instantiate୦୦Set୦float64,) {
	for v := range s {
		if !s2.Contains(v) {
			delete(s, v)
		}
	}
}

func (s instantiate୦୦Set୦float64,) Filter(f func(float64,

//line set.go2:80
) bool) {
	for v := range s {
		if !f(v) {
			delete(s, v)
		}
	}
}

//line set.go2:86
type _ sort.Float64Slice
//line set.go2:86
type _ testing.B
//line set.go2:86
type _ slices.Importable୦
