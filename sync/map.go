// Code generated by go2go; DO NOT EDIT.


//line map.go2:5
package sync

//line map.go2:5
import (
//line map.go2:5
 "math/rand"
//line map.go2:5
 "reflect"
//line map.go2:5
 "runtime"
//line map.go2:5
 "sync"
//line map.go2:5
 "sync/atomic"
//line map.go2:5
 "testing"
//line map.go2:5
 "testing/quick"
//line map.go2:5
 "unsafe"
//line map.go2:5
)

//line map.go2:26
var expunged = unsafe.Pointer(new(interface{}))

type entry struct {
	p unsafe.Pointer
}

func newEntry(i interface{}) *entry {
	return &entry{p: unsafe.Pointer(&i)}
}

//line map.go2:60
func (e *entry) load() (value interface{}, ok bool) {
	p := atomic.LoadPointer(&e.p)
	if p == nil || p == expunged {
		return nil, false
	}
	return *(*interface{})(p), true
}

//line map.go2:107
func (e *entry) delete() (value interface{}, ok bool) {
	for {
		p := atomic.LoadPointer(&e.p)
		if p == nil || p == expunged {
			return nil, false
		}
		if atomic.CompareAndSwapPointer(&e.p, p, nil) {
			return *(*interface{})(p), true
		}
	}
}

//line map.go2:154
func (e *entry) tryLoadOrStore(i interface{}) (actual interface{}, loaded, ok bool) {
	p := atomic.LoadPointer(&e.p)
	if p == expunged {
		return nil, false, false
	}
	if p != nil {
		return *(*interface{})(p), true, true
	}

	ic := i
	for {
		if atomic.CompareAndSwapPointer(&e.p, nil, unsafe.Pointer(&ic)) {
			return i, false, true
		}
		p = atomic.LoadPointer(&e.p)
		if p == expunged {
			return nil, false, false
		}
		if p != nil {
			return *(*interface{})(p), true, true
		}
	}
}

func (e *entry) unexpungeLocked() (wasExpunged bool) {
	return atomic.CompareAndSwapPointer(&e.p, expunged, nil)
}

//line map.go2:196
func (e *entry) tryExpungeLocked() (isExpunged bool) {
	p := atomic.LoadPointer(&e.p)
	for p == nil {
		if atomic.CompareAndSwapPointer(&e.p, nil, expunged) {
			return true
		}
		p = atomic.LoadPointer(&e.p)
	}
	return p == expunged
}

//line map.go2:268
func (e *entry) tryStore(i *interface{}) bool {
	for {
		p := atomic.LoadPointer(&e.p)
		if p == expunged {
			return false
		}
		if atomic.CompareAndSwapPointer(&e.p, p, unsafe.Pointer(i)) {
			return true
		}
	}
}

func (e *entry) storeLocked(i *interface{}) {
	atomic.StorePointer(&e.p, unsafe.Pointer(i))
}

//line map.go2:282
type Importableà­¦ int

//line map.go2:282
var _ = rand.ExpFloat64
//line map.go2:282
var _ = reflect.Append
//line map.go2:282
var _ = runtime.BlockProfile

//line map.go2:282
type _ sync.Cond

//line map.go2:282
var _ = atomic.AddInt32
//line map.go2:282
var _ = testing.AllocsPerRun
//line map.go2:282
var _ = quick.Check

//line map.go2:282
type _ unsafe.Pointer
