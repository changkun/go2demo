// Code generated by go2go; DO NOT EDIT.


//line value_test.go2:5
package atomic

//line value_test.go2:5
import (
//line value_test.go2:5
 "math/rand"
//line value_test.go2:5
 "runtime"
//line value_test.go2:5
 "sync/atomic"
//line value_test.go2:5
 "testing"
//line value_test.go2:5
)

//line value_test.go2:13
func TestValue(t *testing.T) {
	var v instantiate୦୦Value୦int
	v.Store(42)
	x := v.Load()
	if x != 42 {
		t.Fatalf("wrong value: got %+v, want 42", x)
	}
	v.Store(84)
	x = v.Load()
	if x != 84 {
		t.Fatalf("wrong value: got %+v, want 84", x)
	}
}

func TestValueLarge(t *testing.T) {
	var v instantiate୦୦Value୦string
	v.Store("foo")
	x := v.Load()
	if x != "foo" {
		t.Fatalf("wrong value: got %+v, want foo", x)
	}
	v.Store("barbaz")
	x = v.Load()
	if x != "barbaz" {
		t.Fatalf("wrong value: got %+v, want barbaz", x)
	}
}

func TestValuePanic(t *testing.T) {
	const nilErr = "sync/atomic: store of nil value into Value"
	const badErr = "sync/atomic: store of inconsistently typed value into Value"
	var v instantiate୦୦Value୦interface୮4୮5
	func() {
		defer func() {
			err := recover()
			if err != nilErr {
				t.Fatalf("inconsistent store panic: got '%v', want '%v'", err, nilErr)
			}
		}()
		v.Store(nil)
	}()
	v.Store(42)
	func() {
		defer func() {
			err := recover()
			if err != badErr {
				t.Fatalf("inconsistent store panic: got '%v', want '%v'", err, badErr)
			}
		}()
		v.Store("foo")
	}()
	func() {
		defer func() {
			err := recover()
			if err != nilErr {
				t.Fatalf("inconsistent store panic: got '%v', want '%v'", err, nilErr)
			}
		}()
		v.Store(nil)
	}()
}

func TestValueConcurrent(t *testing.T) {
	tests := [][]interface{}{
		{uint16(0), ^uint16(0), uint16(1 + 2<<8), uint16(3 + 4<<8)},
		{uint32(0), ^uint32(0), uint32(1 + 2<<16), uint32(3 + 4<<16)},
		{uint64(0), ^uint64(0), uint64(1 + 2<<32), uint64(3 + 4<<32)},
		{complex(0, 0), complex(1, 2), complex(3, 4), complex(5, 6)},
	}
	p := 4 * runtime.GOMAXPROCS(0)
	N := int(1e5)
	if testing.Short() {
		p /= 2
		N = 1e3
	}
	for _, test := range tests {
		var v instantiate୦୦Value୦interface୮4୮5
		done := make(chan bool, p)
		for i := 0; i < p; i++ {
			go func() {
				r := rand.New(rand.NewSource(rand.Int63()))
				expected := true
			loop:
				for j := 0; j < N; j++ {
					x := test[r.Intn(len(test))]
					v.Store(x)
					x = v.Load()
					for _, x1 := range test {
						if x == x1 {
							continue loop
						}
					}
					t.Logf("loaded unexpected value %+v, want %+v", x, test)
					expected = false
					break
				}
				done <- expected
			}()
		}
		for i := 0; i < p; i++ {
			if !<-done {
				t.FailNow()
			}
		}
	}
}

func BenchmarkValueRead(b *testing.B) {
	var v instantiate୦୦Value୦୮1int
	v.Store(new(int))
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			x := v.Load()
			if *x != 0 {
				b.Fatalf("wrong value: got %v, want 0", *x)
			}
		}
	})
}

//line value_test.go2:131
type instantiate୦୦Value୦int struct {
//line value.go2:11
 val atomic.Value
}

func (v *instantiate୦୦Value୦int,) Load() int {
	x := v.val.Load()
	return x.(int)
}

func (v *instantiate୦୦Value୦int,) Store(val int,

//line value.go2:19
) {
	v.val.Store(interface{}(val))
}

//line value.go2:21
type instantiate୦୦Value୦string struct {
//line value.go2:11
 val atomic.Value
}

func (v *instantiate୦୦Value୦string,) Load() string {
	x := v.val.Load()
	return x.(string)
}

func (v *instantiate୦୦Value୦string,) Store(val string) {
	v.val.Store(interface{}(val))
}

//line value.go2:21
type instantiate୦୦Value୦interface୮4୮5 struct {
//line value.go2:11
 val atomic.Value
}

func (v *instantiate୦୦Value୦interface୮4୮5,) Load() interface{} {
	x := v.val.Load()
	return x.(interface{})
}

func (v *instantiate୦୦Value୦interface୮4୮5,) Store(val interface{}) {
	v.val.Store(interface{}(val))
}

//line value.go2:21
type instantiate୦୦Value୦୮1int struct {
//line value.go2:11
 val atomic.Value
}

func (v *instantiate୦୦Value୦୮1int,) Load() *int {
	x := v.val.Load()
	return x.(*int)
}

func (v *instantiate୦୦Value୦୮1int,) Store(val *int) {
	v.val.Store(interface{}(val))
}

//line value.go2:21
var _ = rand.ExpFloat64
//line value.go2:21
var _ = runtime.BlockProfile
//line value.go2:21
var _ = atomic.AddInt32
//line value.go2:21
var _ = testing.AllocsPerRun
