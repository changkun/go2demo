// Code generated by go2go; DO NOT EDIT.


//line ring_test.go2:5
package ring

//line ring_test.go2:5
import (
//line ring_test.go2:5
 "fmt"
//line ring_test.go2:5
 "testing"
//line ring_test.go2:5
)

//line ring_test.go2:26
func verify(t *testing.T, r *instantiate୦୦Ring୦int, N int, sum int) {

	n := r.Len()
	if n != N {
		t.Errorf("r.Len() == %d; expected %d", n, N)
	}

//line ring_test.go2:34
 n = 0
	var s int
	r.Do(func(p int) {
		n++
		s += p
	})
	if n != N {
		t.Errorf("number of forward iterations == %d; expected %d", n, N)
	}
	if sum >= 0 && s != sum {
		t.Errorf("forward ring sum = %d; expected %d", s, sum)
	}

	if r == nil {
		return
	}

//line ring_test.go2:52
 if r.next != nil {
		var p *instantiate୦୦Ring୦int
		for q := r; p == nil || q != r; q = q.next {
			if p != nil && p != q.prev {
				t.Errorf("prev = %p, expected q.prev = %p\n", p, q.prev)
			}
			p = q
		}
		if p != r.prev {
			t.Errorf("prev = %p, expected r.prev = %p\n", p, r.prev)
		}
	}

//line ring_test.go2:66
 if r.Next() != r.next {
		t.Errorf("r.Next() != r.next")
	}
	if r.Prev() != r.prev {
		t.Errorf("r.Prev() != r.prev")
	}

//line ring_test.go2:74
 if r.Move(0) != r {
		t.Errorf("r.Move(0) != r")
	}
	if r.Move(N) != r {
		t.Errorf("r.Move(%d) != r", N)
	}
	if r.Move(-N) != r {
		t.Errorf("r.Move(%d) != r", -N)
	}
	for i := 0; i < 10; i++ {
		ni := N + i
		mi := ni % N
		if r.Move(ni) != r.Move(mi) {
			t.Errorf("r.Move(%d) != r.Move(%d)", ni, mi)
		}
		if r.Move(-ni) != r.Move(-mi) {
			t.Errorf("r.Move(%d) != r.Move(%d)", -ni, -mi)
		}
	}
}

func TestCornerCases(t *testing.T) {
	var (
		r0 *instantiate୦୦Ring୦int
		r1 instantiate୦୦Ring୦int
	)

	verify(t, r0, 0, 0)
	verify(t, &r1, 1, 0)

	r1.Link(r0)
	verify(t, r0, 0, 0)
	verify(t, &r1, 1, 0)

	r1.Link(r0)
	verify(t, r0, 0, 0)
	verify(t, &r1, 1, 0)

	r1.Unlink(0)
	verify(t, &r1, 1, 0)
}

func makeN(n int) *instantiate୦୦Ring୦int {
	r := instantiate୦୦New୦int(n)
	for i := 1; i <= n; i++ {
		r.Value = i
		r = r.Next()
	}
	return r
}

func sumN(n int) int { return (n*n + n) / 2 }

func TestNew(t *testing.T) {
	for i := 0; i < 10; i++ {
		r := instantiate୦୦New୦int(i)
		verify(t, r, i, -1)
	}
	for i := 0; i < 10; i++ {
		r := makeN(i)
		verify(t, r, i, sumN(i))
	}
}

func TestLink1(t *testing.T) {
	r1a := makeN(1)
	var r1b instantiate୦୦Ring୦int
	r2a := r1a.Link(&r1b)
	verify(t, r2a, 2, 1)
	if r2a != r1a {
		t.Errorf("a) 2-element link failed")
	}

	r2b := r2a.Link(r2a.Next())
	verify(t, r2b, 2, 1)
	if r2b != r2a.Next() {
		t.Errorf("b) 2-element link failed")
	}

	r1c := r2b.Link(r2b)
	verify(t, r1c, 1, 1)
	verify(t, r2b, 1, 0)
}

func TestLink2(t *testing.T) {
	var r0 *instantiate୦୦Ring୦int
	r1a := &instantiate୦୦Ring୦int{Value: 42}
	r1b := &instantiate୦୦Ring୦int{Value: 77}
	r10 := makeN(10)

	r1a.Link(r0)
	verify(t, r1a, 1, 42)

	r1a.Link(r1b)
	verify(t, r1a, 2, 42+77)

	r10.Link(r0)
	verify(t, r10, 10, sumN(10))

	r10.Link(r1a)
	verify(t, r10, 12, sumN(10)+42+77)
}

func TestLink3(t *testing.T) {
	var r instantiate୦୦Ring୦int
	n := 1
	for i := 1; i < 10; i++ {
		n += i
		verify(t, r.Link(instantiate୦୦New୦int(i)), n, -1)
	}
}

func TestUnlink(t *testing.T) {
	r10 := makeN(10)
	s10 := r10.Move(6)

	sum10 := sumN(10)

	verify(t, r10, 10, sum10)
	verify(t, s10, 10, sum10)

	r0 := r10.Unlink(0)
	verify(t, r0, 0, 0)

	r1 := r10.Unlink(1)
	verify(t, r1, 1, 2)
	verify(t, r10, 9, sum10-2)

	r9 := r10.Unlink(9)
	verify(t, r9, 9, sum10-2)
	verify(t, r10, 9, sum10-2)
}

func TestLinkUnlink(t *testing.T) {
	for i := 1; i < 4; i++ {
		ri := instantiate୦୦New୦int(i)
		for j := 0; j < i; j++ {
			rj := ri.Unlink(j)
			verify(t, rj, j, -1)
			verify(t, ri, i-j, -1)
			ri.Link(rj)
			verify(t, ri, i, -1)
		}
	}
}

//line ring_test.go2:221
func TestMoveEmptyRing(t *testing.T) {
	var r instantiate୦୦Ring୦int

	r.Move(1)
	verify(t, &r, 1, 0)
}

//line ring_test.go2:226
type instantiate୦୦Ring୦int struct {
//line ring.go2:15
 next, prev *instantiate୦୦Ring୦int
			Value      int
}

func (r *instantiate୦୦Ring୦int,) init() *instantiate୦୦Ring୦int {
	r.next = r
	r.prev = r
	return r
}

//line ring.go2:26
func (r *instantiate୦୦Ring୦int,) Next() *instantiate୦୦Ring୦int {
	if r.next == nil {
		return r.init()
	}
	return r.next
}

//line ring.go2:34
func (r *instantiate୦୦Ring୦int,) Prev() *instantiate୦୦Ring୦int {
	if r.next == nil {
		return r.init()
	}
	return r.prev
}

//line ring.go2:44
func (r *instantiate୦୦Ring୦int,) Move(n int) *instantiate୦୦Ring୦int {
	if r.next == nil {
		return r.init()
	}
	switch {
	case n < 0:
		for ; n < 0; n++ {
			r = r.prev
		}
	case n > 0:
		for ; n > 0; n-- {
			r = r.next
		}
	}
	return r
}

//line ring.go2:93
func (r *instantiate୦୦Ring୦int,) Link(s *instantiate୦୦Ring୦int,) *instantiate୦୦Ring୦int {
	n := r.Next()
	if s != nil {
				p := s.Prev()

//line ring.go2:99
  r.next = s
		s.prev = r
		n.prev = p
		p.next = n
	}
	return n
}

//line ring.go2:111
func (r *instantiate୦୦Ring୦int,) Unlink(n int) *instantiate୦୦Ring୦int {
	if n <= 0 {
		return nil
	}
	return r.Link(r.Move(n + 1))
}

//line ring.go2:121
func (r *instantiate୦୦Ring୦int,) Len() int {
	n := 0
	if r != nil {
		n = 1
		for p := r.Next(); p != r; p = p.next {
			n++
		}
	}
	return n
}

//line ring.go2:134
func (r *instantiate୦୦Ring୦int,) Do(f func(int,

//line ring.go2:134
)) {
	if r != nil {
		f(r.Value)
		for p := r.Next(); p != r; p = p.next {
			f(p.Value)
		}
	}
}
//line ring.go2:62
func instantiate୦୦New୦int(n int) *instantiate୦୦Ring୦int {
	if n <= 0 {
		return nil
	}
	r := new(instantiate୦୦Ring୦int)
	p := r
	for i := 1; i < n; i++ {
		p.next = &instantiate୦୦Ring୦int{prev: p}
		p = p.next
	}
	p.next = r
	r.prev = p
	return r
}

//line ring.go2:75
var _ = fmt.Errorf
//line ring.go2:75
var _ = testing.AllocsPerRun
