// Copyright 2020 Changkun Ou. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// naive generic map[k]v
type Pair[type T1, T2] struct {
	Key   T1
	Value T2
}
type Map[type T1 comparable, T2 interface{}] struct {
	s []Pair[T1, T2]
}
func NewMap[type T1 comparable, T2 interface{}] () Map[T1, T2] {
	return Map[T1, T2]{s: [](Pair[T1, T2]){}}
}
func (m *Map[T1, T2]) Set(k T1, v T2) {
	m.s = append(m.s, Pair[T1, T2]{k, v})
}
func (m *Map[T1, T2]) Get(k T1) (v T2, ok bool) {
	for _, p := range m.s {
		if p.Key == k {
			return p.Value, true
		}
	}
	return
}

func main() {
	m := NewMap[int, float64]()
	m.Set(1, 2.0)
	m.Set(2, 3.0)
	m.Set(3, 4.0)

	if v, ok := m.Get(1); !ok || v != 2.0 {
		panic("get 1 fail")
	}
	if v, ok := m.Get(2); !ok || v != 3.0 {
		panic("get 2 fail")
	}
	if v, ok := m.Get(3); !ok || v != 4.0 {
		panic("get 3 fail")
	}
	println("OK")
}
